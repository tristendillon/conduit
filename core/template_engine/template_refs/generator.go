package template_refs

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/tristendillon/conduit/core/logger"
	"github.com/tristendillon/conduit/core/shared"
)

type TemplateGenerator struct {
	walker     *TemplateWalker
	outputPath string
}

func NewTemplateGenerator(walker *TemplateWalker) *TemplateGenerator {
	parentDir := filepath.Dir(walker.templateDir)
	outputPath := filepath.Join(parentDir, "gen_template_refs.go")

	return &TemplateGenerator{
		walker:     walker,
		outputPath: outputPath,
	}
}

func (tg *TemplateGenerator) Generate() error {
	rootNode := tg.walker.GetTemplateTree()

	code, err := tg.generateCode(rootNode)
	if err != nil {
		return fmt.Errorf("failed to generate code: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(tg.outputPath), 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	if err := os.WriteFile(tg.outputPath, []byte(code), 0644); err != nil {
		return fmt.Errorf("failed to write generated file: %w", err)
	}

	return nil
}

func (tg *TemplateGenerator) generateCode(rootNode *TemplateNode) (string, error) {
	tmpl := `// Code generated by template_refs generator. DO NOT EDIT.
package template_engine

import "embed"

//go:embed templates/* templates/**/_*/**/*
var TemplateFS embed.FS

{{range .StructDefinitions}}{{.}}

{{end}}// TEMPLATES provides type-safe access to all template references
var TEMPLATES = {{.RootStructName}}{
{{.RootStructInit}}
}
`

	structDefs, rootStructName, rootStructInit := tg.generateStructDefinitions(rootNode)

	data := struct {
		StructDefinitions []string
		RootStructName    string
		RootStructInit    string
		TemplateDir       string
	}{
		StructDefinitions: structDefs,
		RootStructName:    rootStructName,
		RootStructInit:    rootStructInit,
		TemplateDir:       tg.walker.templateDir,
	}

	t, err := template.New("generator").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf strings.Builder
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

func (tg *TemplateGenerator) generateStructDefinitions(rootNode *TemplateNode) ([]string, string, string) {
	var structDefs []string
	structMap := make(map[string]string)
	initMap := make(map[string]string)

	rootStructName := tg.generateStructsRecursively(rootNode, structMap, initMap)

	var structNames []string
	for name := range structMap {
		structNames = append(structNames, name)
	}
	sort.Strings(structNames)

	for _, name := range structNames {
		structDefs = append(structDefs, structMap[name])
	}

	return structDefs, rootStructName, initMap[rootStructName]
}

func (tg *TemplateGenerator) generateStructsRecursively(node *TemplateNode, structMap, initMap map[string]string) string {
	if !node.IsDir || len(node.Children) == 0 {
		return ""
	}

	structName := tg.generateStructName(node)

	var fields []string
	var initFields []string

	fields = append(fields, "\tRef TemplateRef")
	initFields = append(initFields, fmt.Sprintf("\tRef: TemplateRef{Path: %q, IsDir: true},", node.Path))

	var childNames []string
	for name := range node.Children {
		childNames = append(childNames, name)
	}
	sort.Strings(childNames)

	for _, childName := range childNames {
		child := node.Children[childName]
		fieldName := childName

		if child.IsDir && len(child.Children) > 0 {
			childStructName := tg.generateStructsRecursively(child, structMap, initMap)
			fields = append(fields, fmt.Sprintf("\t%s %s", fieldName, childStructName))
			initFields = append(initFields, fmt.Sprintf("\t%s: %s{\n%s\n\t},", fieldName, childStructName, initMap[childStructName]))
		} else {
			fields = append(fields, fmt.Sprintf("\t%s TemplateRef", fieldName))
			initFields = append(initFields, fmt.Sprintf("\t%s: TemplateRef{Path: %q, IsDir: %t},",
				fieldName, child.Path, child.IsDir))
		}
	}

	structDef := fmt.Sprintf("type %s struct {\n%s\n}", structName, strings.Join(fields, "\n"))
	structMap[structName] = structDef

	initCode := strings.Join(initFields, "\n")
	initMap[structName] = initCode

	return structName
}

func (tg *TemplateGenerator) generateStructName(node *TemplateNode) string {
	if node.Path == "" {
		return "TemplateRefs"
	}

	parts := strings.Split(node.Path, "/")
	var nameParts []string

	for _, part := range parts {
		normalized := tg.walker.normalizeKey(part)
		if normalized != "" {
			nameParts = append(nameParts, shared.ToTitle(strings.ToLower(normalized)))
		}
	}

	name := strings.Join(nameParts, "") + "Templates"

	if len(name) > 0 {
		name = strings.ToUpper(name[:1]) + name[1:]
	}

	return name
}

func GenerateToFile(templatesDir, outputPath string) error {
	walker := NewTemplateWalker(templatesDir)
	if err := walker.Walk(); err != nil {
		return fmt.Errorf("failed to walk templates directory: %w", err)
	}

	generator := NewTemplateGenerator(walker)
	if err := generator.Generate(); err != nil {
		return fmt.Errorf("failed to generate template references: %w", err)
	}

	return nil
}

func (tg *TemplateGenerator) PrintTemplateTree() {
	tg.printNode(tg.walker.GetTemplateTree(), 0)
}

func (tg *TemplateGenerator) printNode(node *TemplateNode, depth int) {
	indent := strings.Repeat("  ", depth)
	nodeType := "FILE"
	if node.IsDir {
		nodeType = "DIR"
	}

	logger.Debug("%s[%s] %s -> %s", indent, nodeType, node.Name, node.Path)

	var childNames []string
	for name := range node.Children {
		childNames = append(childNames, name)
	}
	sort.Strings(childNames)

	for _, childName := range childNames {
		tg.printNode(node.Children[childName], depth+1)
	}
}
